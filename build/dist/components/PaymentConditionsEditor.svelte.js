import './PaymentConditionsEditor.svelte.css.proxy.js';
/* src\components\PaymentConditionsEditor.svelte generated by Svelte v3.46.3 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	safe_not_equal,
	set_store_value,
	space,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import { getContext } from '../../_snowpack/pkg/svelte.js';
import InputMask from './InputMask.svelte.js';

function create_fragment(ctx) {
	let div5;
	let div4;
	let div0;
	let label0;
	let t1;
	let inputmask0;
	let updating_value;
	let t2;
	let div1;
	let label1;
	let t4;
	let inputmask1;
	let updating_value_1;
	let t5;
	let div2;
	let label2;
	let t7;
	let inputmask2;
	let updating_value_2;
	let t8;
	let div3;
	let button;
	let current;
	let mounted;
	let dispose;

	function inputmask0_value_binding(value) {
		/*inputmask0_value_binding*/ ctx[9](value);
	}

	let inputmask0_props = {
		type: "text",
		name: "first",
		class: "flex items-center w-full h-10 px-4 mt-1 text-sm border-2 rounded",
		unmask: "typed",
		imask: /*valueOptions*/ ctx[5]
	};

	if (/*values*/ ctx[0].first !== void 0) {
		inputmask0_props.value = /*values*/ ctx[0].first;
	}

	inputmask0 = new InputMask({ props: inputmask0_props });
	binding_callbacks.push(() => bind(inputmask0, 'value', inputmask0_value_binding));

	function inputmask1_value_binding(value) {
		/*inputmask1_value_binding*/ ctx[10](value);
	}

	let inputmask1_props = {
		type: "text",
		name: "second",
		class: "flex items-center w-full h-10 px-4 mt-1 text-sm border-2 rounded",
		unmask: "typed",
		imask: /*valueOptions*/ ctx[5]
	};

	if (/*values*/ ctx[0].second !== void 0) {
		inputmask1_props.value = /*values*/ ctx[0].second;
	}

	inputmask1 = new InputMask({ props: inputmask1_props });
	binding_callbacks.push(() => bind(inputmask1, 'value', inputmask1_value_binding));

	function inputmask2_value_binding(value) {
		/*inputmask2_value_binding*/ ctx[11](value);
	}

	let inputmask2_props = {
		type: "text",
		name: "third",
		class: "flex items-center w-full h-10 px-4 mt-1 text-sm border-2 rounded",
		unmask: "typed",
		imask: /*valueOptions*/ ctx[5]
	};

	if (/*values*/ ctx[0].third !== void 0) {
		inputmask2_props.value = /*values*/ ctx[0].third;
	}

	inputmask2 = new InputMask({ props: inputmask2_props });
	binding_callbacks.push(() => bind(inputmask2, 'value', inputmask2_value_binding));

	return {
		c() {
			div5 = element("div");
			div4 = element("div");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = "Primeira Coluna";
			t1 = space();
			create_component(inputmask0.$$.fragment);
			t2 = space();
			div1 = element("div");
			label1 = element("label");
			label1.textContent = "Segunda Coluna";
			t4 = space();
			create_component(inputmask1.$$.fragment);
			t5 = space();
			div2 = element("div");
			label2 = element("label");
			label2.textContent = "Terceira Coluna";
			t7 = space();
			create_component(inputmask2.$$.fragment);
			t8 = space();
			div3 = element("div");
			button = element("button");

			button.textContent = `${/*isCreating*/ ctx[6]
			? 'Criar Condição de Pagamento'
			: 'Salvar Alterações'}`;

			attr(label0, "for", "first");
			attr(label0, "class", "label svelte-1rjj6pj");
			attr(div0, "class", "col-span-full");
			attr(label1, "for", "second");
			attr(label1, "class", "label svelte-1rjj6pj");
			attr(div1, "class", "col-span-full");
			attr(label2, "for", "third");
			attr(label2, "class", "label svelte-1rjj6pj");
			attr(div2, "class", "col-span-full");
			attr(button, "class", "w-full font-medium bg-main-500 button hover:bg-main-600 active:bg-main-400 svelte-1rjj6pj");
			attr(div3, "class", "h-10 mt-3 col-span-full");
			attr(div4, "class", "grid w-full grid-cols-4 gap-4 px-4 pb-4");
			attr(div5, "class", "flex items-center w-full pt-8");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div4);
			append(div4, div0);
			append(div0, label0);
			append(div0, t1);
			mount_component(inputmask0, div0, null);
			append(div4, t2);
			append(div4, div1);
			append(div1, label1);
			append(div1, t4);
			mount_component(inputmask1, div1, null);
			append(div4, t5);
			append(div4, div2);
			append(div2, label2);
			append(div2, t7);
			mount_component(inputmask2, div2, null);
			append(div4, t8);
			append(div4, div3);
			append(div3, button);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*handleSubmit*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const inputmask0_changes = {};

			if (!updating_value && dirty & /*values*/ 1) {
				updating_value = true;
				inputmask0_changes.value = /*values*/ ctx[0].first;
				add_flush_callback(() => updating_value = false);
			}

			inputmask0.$set(inputmask0_changes);
			const inputmask1_changes = {};

			if (!updating_value_1 && dirty & /*values*/ 1) {
				updating_value_1 = true;
				inputmask1_changes.value = /*values*/ ctx[0].second;
				add_flush_callback(() => updating_value_1 = false);
			}

			inputmask1.$set(inputmask1_changes);
			const inputmask2_changes = {};

			if (!updating_value_2 && dirty & /*values*/ 1) {
				updating_value_2 = true;
				inputmask2_changes.value = /*values*/ ctx[0].third;
				add_flush_callback(() => updating_value_2 = false);
			}

			inputmask2.$set(inputmask2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(inputmask0.$$.fragment, local);
			transition_in(inputmask1.$$.fragment, local);
			transition_in(inputmask2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(inputmask0.$$.fragment, local);
			transition_out(inputmask1.$$.fragment, local);
			transition_out(inputmask2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			destroy_component(inputmask0);
			destroy_component(inputmask1);
			destroy_component(inputmask2);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $newPaymentConditionReady;
	let $paymentConditionEditReady;
	let $newPaymentConditionInfo;
	let $paymentConditionEditIndex;
	let { isNew = false } = $$props;
	const newPaymentConditionInfo = getContext('newPaymentConditionInfo');
	component_subscribe($$self, newPaymentConditionInfo, value => $$invalidate(14, $newPaymentConditionInfo = value));
	const newPaymentConditionReady = getContext('newPaymentConditionReady');
	component_subscribe($$self, newPaymentConditionReady, value => $$invalidate(12, $newPaymentConditionReady = value));
	const paymentConditionEditReady = getContext('paymentConditionEditReady');
	component_subscribe($$self, paymentConditionEditReady, value => $$invalidate(13, $paymentConditionEditReady = value));
	const paymentConditionEditIndex = getContext('paymentConditionEditIndex');
	component_subscribe($$self, paymentConditionEditIndex, value => $$invalidate(15, $paymentConditionEditIndex = value));
	let values = { first: '', second: '', third: '' };

	// Input masks
	const valueOptions = {
		mask: /^[A-Za-zÀ-ÖØ-öø-ÿ0-9\(\)\-\+\,\.\[\]\!\*\%\=\/\$\;\:\s]+$/
	};

	const isCreating = $paymentConditionEditIndex === null || isNew;

	// If we're editing an existing product order, get the data from the store
	if (!isCreating) {
		values = { ...$newPaymentConditionInfo };
	}

	// Helpers
	const { close } = getContext('simple-modal');

	const handleSubmit = () => {
		if (values.first === '') {
			alert('Preencha a primeira coluna!');
			return;
		}

		if (values.second === '') {
			alert('Preencha a segunda coluna!');
			return;
		}

		if (values.third === '') {
			alert('Preencha a terceira coluna!');
			return;
		}

		set_store_value(newPaymentConditionInfo, $newPaymentConditionInfo = { ...values }, $newPaymentConditionInfo);

		if (!isCreating) {
			set_store_value(paymentConditionEditReady, $paymentConditionEditReady = true, $paymentConditionEditReady);
		} else {
			set_store_value(newPaymentConditionReady, $newPaymentConditionReady = true, $newPaymentConditionReady);
		}

		close();
	};

	function inputmask0_value_binding(value) {
		if ($$self.$$.not_equal(values.first, value)) {
			values.first = value;
			$$invalidate(0, values);
		}
	}

	function inputmask1_value_binding(value) {
		if ($$self.$$.not_equal(values.second, value)) {
			values.second = value;
			$$invalidate(0, values);
		}
	}

	function inputmask2_value_binding(value) {
		if ($$self.$$.not_equal(values.third, value)) {
			values.third = value;
			$$invalidate(0, values);
		}
	}

	$$self.$$set = $$props => {
		if ('isNew' in $$props) $$invalidate(8, isNew = $$props.isNew);
	};

	return [
		values,
		newPaymentConditionInfo,
		newPaymentConditionReady,
		paymentConditionEditReady,
		paymentConditionEditIndex,
		valueOptions,
		isCreating,
		handleSubmit,
		isNew,
		inputmask0_value_binding,
		inputmask1_value_binding,
		inputmask2_value_binding
	];
}

class PaymentConditionsEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { isNew: 8 });
	}
}

export default PaymentConditionsEditor;