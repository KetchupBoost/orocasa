import './ProductOrderEditor.svelte.css.proxy.js';
/* src\components\ProductOrderEditor.svelte generated by Svelte v3.46.3 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_block,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	outro_and_destroy_block,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	set_store_value,
	set_style,
	space,
	svg_element,
	text,
	to_number,
	transition_in,
	transition_out,
	update_keyed_each
} from "../../_snowpack/pkg/svelte/internal.js";

import { getContext } from '../../_snowpack/pkg/svelte.js';
import { Doc } from '../../_snowpack/pkg/sveltefire.js';
import firebase from '../../_snowpack/pkg/firebase/app.js';
import '../../_snowpack/pkg/firebase/firestore.js';
import '../../_snowpack/pkg/firebase/storage.js';
import InputMask from './InputMask.svelte.js';
import ProductSelect from './ProductSelect.svelte.js';
import Multiselect from './Multiselect.svelte.js';
import { is_empty } from '../../_snowpack/pkg/svelte/internal.js';
import { select } from './removeSelect.js';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i][0];
	child_ctx[32] = list[i][1];
	child_ctx[33] = list;
	child_ctx[34] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[36] = list[i];
	child_ctx[38] = i;
	return child_ctx;
}

// (206:4) {:else}
function create_else_block(ctx) {
	let div4;
	let label0;
	let t1;
	let div3;
	let div1;
	let div0;
	let t2;
	let div2;
	let span;
	let t3_value = /*selectedProduct*/ ctx[0].name + "";
	let t3;
	let t4;
	let button0;
	let t6;
	let div5;
	let label1;
	let t8;
	let inputmask;
	let updating_value;
	let t9;
	let div7;
	let label2;
	let t11;
	let div6;
	let button1;
	let svg0;
	let path0;
	let button1_disabled_value;
	let t12;
	let input;
	let t13;
	let button2;
	let t14;
	let div8;
	let label3;
	let t16;
	let multiselect;
	let updating_items;
	let updating_selected;
	let t17;
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	function inputmask_value_binding(value) {
		/*inputmask_value_binding*/ ctx[19](value);
	}

	let inputmask_props = {
		type: "text",
		name: "ambient",
		class: "flex items-center w-full h-10 px-4 mt-1 text-sm border-2 rounded",
		unmask: "typed",
		imask: /*ambientOptions*/ ctx[8]
	};

	if (/*values*/ ctx[1].ambient !== void 0) {
		inputmask_props.value = /*values*/ ctx[1].ambient;
	}

	inputmask = new InputMask({ props: inputmask_props });
	binding_callbacks.push(() => bind(inputmask, 'value', inputmask_value_binding));

	function multiselect_items_binding(value) {
		/*multiselect_items_binding*/ ctx[21](value);
	}

	function multiselect_selected_binding(value) {
		/*multiselect_selected_binding*/ ctx[22](value);
	}

	let multiselect_props = { title: "Selecione um ou mais atributos" };

	if (/*featureItems*/ ctx[3] !== void 0) {
		multiselect_props.items = /*featureItems*/ ctx[3];
	}

	if (/*selectedFeatures*/ ctx[2] !== void 0) {
		multiselect_props.selected = /*selectedFeatures*/ ctx[2];
	}

	multiselect = new Multiselect({ props: multiselect_props });
	binding_callbacks.push(() => bind(multiselect, 'items', multiselect_items_binding));
	binding_callbacks.push(() => bind(multiselect, 'selected', multiselect_selected_binding));
	const if_block_creators = [create_if_block_1, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (dirty[0] & /*values*/ 2) show_if = null;
		if (show_if == null) show_if = !!(Object.keys(/*values*/ ctx[1].features).length === 0);
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div4 = element("div");
			label0 = element("label");
			label0.textContent = "Produto";
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			t2 = space();
			div2 = element("div");
			span = element("span");
			t3 = text(t3_value);
			t4 = space();
			button0 = element("button");
			button0.textContent = "Alterar Produto";
			t6 = space();
			div5 = element("div");
			label1 = element("label");
			label1.textContent = "Ambiente";
			t8 = space();
			create_component(inputmask.$$.fragment);
			t9 = space();
			div7 = element("div");
			label2 = element("label");
			label2.textContent = "Quantidade";
			t11 = space();
			div6 = element("div");
			button1 = element("button");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			t12 = space();
			input = element("input");
			t13 = space();
			button2 = element("button");
			button2.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>`;
			t14 = space();
			div8 = element("div");
			label3 = element("label");
			label3.textContent = "Atributos";
			t16 = space();
			create_component(multiselect.$$.fragment);
			t17 = space();
			if_block.c();
			if_block_anchor = empty();
			attr(label0, "for", "product");
			attr(label0, "class", "label svelte-4ngngh");
			attr(div0, "class", "w-full h-full bg-center bg-no-repeat bg-contain");
			set_style(div0, "background-image", "url(" + /*selectedProduct*/ ctx[0].image + ")");
			attr(div1, "class", "w-40 h-40 rounded");
			attr(span, "class", "text-xl font-semibold");
			attr(button0, "class", "px-3 py-2 mt-4 font-medium bg-main-500 button hover:bg-main-600 active:bg-main-400 svelte-4ngngh");
			attr(div2, "class", "flex flex-col items-center justify-center w-full");
			attr(div3, "class", "flex items-center w-full h-40 mt-1");
			attr(div4, "class", "col-span-full");
			attr(label1, "for", "ambient");
			attr(label1, "class", "label svelte-4ngngh");
			attr(div5, "class", "col-span-full");
			attr(label2, "for", "count");
			attr(label2, "class", "label svelte-4ngngh");
			attr(path0, "fill-rule", "evenodd");
			attr(path0, "d", "M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z");
			attr(path0, "clip-rule", "evenodd");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "class", "w-5 h-5");
			attr(svg0, "viewBox", "0 0 20 20");
			attr(svg0, "fill", "currentColor");
			attr(button1, "class", "w-10 bg-main-500 button hover:bg-main-600 active:bg-main-400 svelte-4ngngh");
			attr(button1, "title", "Diminuir");
			button1.disabled = button1_disabled_value = /*values*/ ctx[1].count === 0 || /*values*/ ctx[1].count === null;
			attr(input, "type", "number");
			attr(input, "name", "count");
			attr(input, "class", "flex items-center w-full h-10 px-4 text-sm text-center border-2 rounded svelte-4ngngh");
			attr(button2, "class", "w-10 bg-main-500 button hover:bg-main-600 active:bg-main-400 svelte-4ngngh");
			attr(button2, "title", "Aumentar");
			attr(div6, "class", "flex items-center justify-between w-full h-10 gap-2 mt-1");
			attr(div7, "class", "col-span-full");
			attr(label3, "for", "features");
			attr(label3, "class", "label svelte-4ngngh");
			attr(div8, "class", "col-span-full");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, label0);
			append(div4, t1);
			append(div4, div3);
			append(div3, div1);
			append(div1, div0);
			append(div3, t2);
			append(div3, div2);
			append(div2, span);
			append(span, t3);
			append(div2, t4);
			append(div2, button0);
			insert(target, t6, anchor);
			insert(target, div5, anchor);
			append(div5, label1);
			append(div5, t8);
			mount_component(inputmask, div5, null);
			insert(target, t9, anchor);
			insert(target, div7, anchor);
			append(div7, label2);
			append(div7, t11);
			append(div7, div6);
			append(div6, button1);
			append(button1, svg0);
			append(svg0, path0);
			append(div6, t12);
			append(div6, input);
			set_input_value(input, /*values*/ ctx[1].count);
			append(div6, t13);
			append(div6, button2);
			insert(target, t14, anchor);
			insert(target, div8, anchor);
			append(div8, label3);
			append(div8, t16);
			mount_component(multiselect, div8, null);
			insert(target, t17, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*deselectProduct*/ ctx[11]),
					listen(button1, "click", /*decreaseCount*/ ctx[12]),
					listen(input, "input", /*input_input_handler*/ ctx[20]),
					listen(input, "change", /*handleCountChange*/ ctx[14]),
					listen(button2, "click", /*increaseCount*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*selectedProduct*/ 1) {
				set_style(div0, "background-image", "url(" + /*selectedProduct*/ ctx[0].image + ")");
			}

			if ((!current || dirty[0] & /*selectedProduct*/ 1) && t3_value !== (t3_value = /*selectedProduct*/ ctx[0].name + "")) set_data(t3, t3_value);
			const inputmask_changes = {};

			if (!updating_value && dirty[0] & /*values*/ 2) {
				updating_value = true;
				inputmask_changes.value = /*values*/ ctx[1].ambient;
				add_flush_callback(() => updating_value = false);
			}

			inputmask.$set(inputmask_changes);

			if (!current || dirty[0] & /*values*/ 2 && button1_disabled_value !== (button1_disabled_value = /*values*/ ctx[1].count === 0 || /*values*/ ctx[1].count === null)) {
				button1.disabled = button1_disabled_value;
			}

			if (dirty[0] & /*values*/ 2 && to_number(input.value) !== /*values*/ ctx[1].count) {
				set_input_value(input, /*values*/ ctx[1].count);
			}

			const multiselect_changes = {};

			if (!updating_items && dirty[0] & /*featureItems*/ 8) {
				updating_items = true;
				multiselect_changes.items = /*featureItems*/ ctx[3];
				add_flush_callback(() => updating_items = false);
			}

			if (!updating_selected && dirty[0] & /*selectedFeatures*/ 4) {
				updating_selected = true;
				multiselect_changes.selected = /*selectedFeatures*/ ctx[2];
				add_flush_callback(() => updating_selected = false);
			}

			multiselect.$set(multiselect_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(inputmask.$$.fragment, local);
			transition_in(multiselect.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(inputmask.$$.fragment, local);
			transition_out(multiselect.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			if (detaching) detach(t6);
			if (detaching) detach(div5);
			destroy_component(inputmask);
			if (detaching) detach(t9);
			if (detaching) detach(div7);
			if (detaching) detach(t14);
			if (detaching) detach(div8);
			destroy_component(multiselect);
			if (detaching) detach(t17);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (200:4) {#if selectedProduct === null}
function create_if_block(ctx) {
	let div;
	let label;
	let t1;
	let productselect;
	let updating_selected;
	let current;

	function productselect_selected_binding(value) {
		/*productselect_selected_binding*/ ctx[18](value);
	}

	let productselect_props = {};

	if (/*selectedProduct*/ ctx[0] !== void 0) {
		productselect_props.selected = /*selectedProduct*/ ctx[0];
	}

	productselect = new ProductSelect({ props: productselect_props });
	binding_callbacks.push(() => bind(productselect, 'selected', productselect_selected_binding));

	return {
		c() {
			div = element("div");
			label = element("label");
			label.textContent = "Produto";
			t1 = space();
			create_component(productselect.$$.fragment);
			attr(label, "for", "product");
			attr(label, "class", "label svelte-4ngngh");
			attr(div, "class", "col-span-full");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label);
			append(div, t1);
			mount_component(productselect, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const productselect_changes = {};

			if (!updating_selected && dirty[0] & /*selectedProduct*/ 1) {
				updating_selected = true;
				productselect_changes.selected = /*selectedProduct*/ ctx[0];
				add_flush_callback(() => updating_selected = false);
			}

			productselect.$set(productselect_changes);
		},
		i(local) {
			if (current) return;
			transition_in(productselect.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(productselect.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(productselect);
		}
	};
}

// (303:6) {:else}
function create_else_block_1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t0;
	let div;
	let button;
	let current;
	let mounted;
	let dispose;
	let each_value = Object.entries(/*values*/ ctx[1].features);
	const get_key = ctx => /*key*/ ctx[31];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div = element("div");
			button = element("button");

			button.textContent = `${/*isCreating*/ ctx[10]
			? 'Criar Ordem de Produto'
			: 'Salvar Alterações'}`;

			attr(button, "class", "w-full font-medium bg-main-500 button hover:bg-main-600 active:bg-main-400 svelte-4ngngh");
			attr(div, "class", "h-10 col-span-4 mt-3");
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t0, anchor);
			insert(target, div, anchor);
			append(div, button);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*handleSubmit*/ ctx[15]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*values, featureValueOptions*/ 514 | dirty[1] & /*data*/ 16) {
				each_value = Object.entries(/*values*/ ctx[1].features);
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, t0.parentNode, outro_and_destroy_block, create_each_block, t0, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(t0);
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (289:6) {#if Object.keys(values.features).length === 0}
function create_if_block_1(ctx) {
	let div1;
	let t1;
	let div2;
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			div1 = element("div");
			div1.innerHTML = `<div class="w-full text-sm font-semibold">Carregando atributos...</div>`;
			t1 = space();
			div2 = element("div");
			button = element("button");

			button.textContent = `${/*isCreating*/ ctx[10]
			? 'Criar Ordem de Produto'
			: 'Salvar Alterações'}`;

			attr(div1, "class", "col-span-full");
			attr(button, "class", "w-full font-medium bg-main-500 button hover:bg-main-600 active:bg-main-400 svelte-4ngngh");
			attr(div2, "class", "h-10 col-span-4 mt-3");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			insert(target, t1, anchor);
			insert(target, div2, anchor);
			append(div2, button);

			if (!mounted) {
				dispose = listen(button, "click", /*handleSubmit*/ ctx[15]);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			if (detaching) detach(t1);
			if (detaching) detach(div2);
			mounted = false;
			dispose();
		}
	};
}

// (318:14) {:else}
function create_else_block_2(ctx) {
	let button;
	let div0;
	let span;
	let t0_value = /*values*/ ctx[1].features[/*key*/ ctx[31]].value + "";
	let t0;
	let t1;
	let svg;
	let path;
	let t2;
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value_1 = /*data*/ ctx[35].values;
	const get_key = ctx => /*i*/ ctx[38];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	return {
		c() {
			button = element("button");
			div0 = element("div");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			t2 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(span, "class", "font-medium");
			attr(path, "fill-rule", "evenodd");
			attr(path, "d", "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z");
			attr(path, "clip-rule", "evenodd");
			attr(svg, "class", "w-4 h-4");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "fill", "currentColor");
			attr(div0, "class", "flex items-center justify-between h-10 px-3 border-2 border-gray-200 rounded hover:bg-gray-200");
			attr(div1, "class", "absolute z-10 flex-col items-start hidden w-full pb-1 bg-white rounded shadow-lg group-focus:flex svelte-4ngngh");
			attr(button, "class", "relative w-full mt-1 text-sm focus:outline-none group svelte-4ngngh");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, div0);
			append(div0, span);
			append(span, t0);
			append(div0, t1);
			append(div0, svg);
			append(svg, path);
			append(button, t2);
			append(button, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*values*/ 2 && t0_value !== (t0_value = /*values*/ ctx[1].features[/*key*/ ctx[31]].value + "")) set_data(t0, t0_value);

			if (dirty[0] & /*values*/ 2 | dirty[1] & /*data*/ 16) {
				each_value_1 = /*data*/ ctx[35].values;
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div1, destroy_block, create_each_block_1, null, get_each_context_1);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(button);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

// (309:14) {#if data.is_open}
function create_if_block_2(ctx) {
	let inputmask;
	let updating_value;
	let current;

	function inputmask_value_binding_1(value) {
		/*inputmask_value_binding_1*/ ctx[23](value, /*key*/ ctx[31]);
	}

	let inputmask_props = {
		type: "text",
		name: "feature-" + /*key*/ ctx[31],
		class: "flex items-center w-full h-10 px-4 mt-1 text-sm border-2 rounded",
		unmask: "typed",
		imask: /*featureValueOptions*/ ctx[9]
	};

	if (/*values*/ ctx[1].features[/*key*/ ctx[31]].value !== void 0) {
		inputmask_props.value = /*values*/ ctx[1].features[/*key*/ ctx[31]].value;
	}

	inputmask = new InputMask({ props: inputmask_props });
	binding_callbacks.push(() => bind(inputmask, 'value', inputmask_value_binding_1));

	return {
		c() {
			create_component(inputmask.$$.fragment);
		},
		m(target, anchor) {
			mount_component(inputmask, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const inputmask_changes = {};
			if (dirty[0] & /*values*/ 2) inputmask_changes.name = "feature-" + /*key*/ ctx[31];

			if (!updating_value && dirty[0] & /*values*/ 2) {
				updating_value = true;
				inputmask_changes.value = /*values*/ ctx[1].features[/*key*/ ctx[31]].value;
				add_flush_callback(() => updating_value = false);
			}

			inputmask.$set(inputmask_changes);
		},
		i(local) {
			if (current) return;
			transition_in(inputmask.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(inputmask.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(inputmask, detaching);
		}
	};
}

// (329:20) {#each data.values as item, i (i)}
function create_each_block_1(key_1, ctx) {
	let button;
	let t_value = /*item*/ ctx[36].value + "";
	let t;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[24](/*key*/ ctx[31], /*item*/ ctx[36]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", "w-full px-4 py-2 text-left hover:bg-gray-200");
			this.first = button;
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[1] & /*data*/ 16 && t_value !== (t_value = /*item*/ ctx[36].value + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (308:12) <Doc path={`fields/${key}`} let:data>
function create_default_slot(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block_2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*data*/ ctx[35].is_open) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (304:8) {#each Object.entries(values.features) as [key, feature] (key)}
function create_each_block(key_1, ctx) {
	let div;
	let label;
	let t0;
	let t1_value = /*values*/ ctx[1].features[/*key*/ ctx[31]].name + "";
	let t1;
	let label_for_value;
	let t2;
	let doc;
	let current;

	doc = new Doc({
			props: {
				path: `fields/${/*key*/ ctx[31]}`,
				$$slots: {
					default: [
						create_default_slot,
						({ data }) => ({ 35: data }),
						({ data }) => [0, data ? 16 : 0]
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			label = element("label");
			t0 = text("Detalhes ");
			t1 = text(t1_value);
			t2 = space();
			create_component(doc.$$.fragment);
			attr(label, "for", label_for_value = "feature-" + /*key*/ ctx[31]);
			attr(label, "class", "label svelte-4ngngh");
			attr(div, "class", "col-span-full");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label);
			append(label, t0);
			append(label, t1);
			append(div, t2);
			mount_component(doc, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*values*/ 2) && t1_value !== (t1_value = /*values*/ ctx[1].features[/*key*/ ctx[31]].name + "")) set_data(t1, t1_value);

			if (!current || dirty[0] & /*values*/ 2 && label_for_value !== (label_for_value = "feature-" + /*key*/ ctx[31])) {
				attr(label, "for", label_for_value);
			}

			const doc_changes = {};
			if (dirty[0] & /*values*/ 2) doc_changes.path = `fields/${/*key*/ ctx[31]}`;

			if (dirty[0] & /*values*/ 2 | dirty[1] & /*$$scope, data*/ 272) {
				doc_changes.$$scope = { dirty, ctx };
			}

			doc.$set(doc_changes);
		},
		i(local) {
			if (current) return;
			transition_in(doc.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(doc.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(doc);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*selectedProduct*/ ctx[0] === null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			attr(div0, "class", "grid w-full grid-cols-4 gap-4 px-4 pb-4");
			attr(div1, "class", "flex items-center w-full pt-8");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $newOrderReady;
	let $orderEditReady;
	let $newOrderInfo;
	let $orderEditIndex;
	let { isNew = false } = $$props;
	let { selectedProduct = null } = $$props;
	const newOrderInfo = getContext('newOrderInfo');
	component_subscribe($$self, newOrderInfo, value => $$invalidate(27, $newOrderInfo = value));
	const newOrderReady = getContext('newOrderReady');
	component_subscribe($$self, newOrderReady, value => $$invalidate(25, $newOrderReady = value));
	const orderEditReady = getContext('orderEditReady');
	component_subscribe($$self, orderEditReady, value => $$invalidate(26, $orderEditReady = value));
	const orderEditIndex = getContext('orderEditIndex');
	component_subscribe($$self, orderEditIndex, value => $$invalidate(28, $orderEditIndex = value));

	let values = {
		id: null,
		count: 0,
		ambient: '',
		features: {}
	};

	let featureItems = {};
	let selectedFeatures = [];
	let selectedEdit = false;

	// Input masks
	const ambientOptions = { mask: /^[A-Za-zÀ-ÖØ-öø-ÿ0-9\(\)\-\s]+$/ };

	const featureValueOptions = {
		mask: /^[A-Za-zÀ-ÖØ-öø-ÿ0-9\(\)\-\,\.\[\]\!\*\%\=\/\s]+$/
	};

	const isCreating = $orderEditIndex === null || isNew;
	const db = firebase.firestore();

	// Fetch all feature from firebase
	db.collection('fields').get().then(snapshot => {
		snapshot.forEach(doc => {
			$$invalidate(3, featureItems[doc.id] = doc.data().name, featureItems);
		});

		$$invalidate(3, featureItems = { ...featureItems });
	});

	// If we're editing an existing product order, get the data from the store
	if (!isCreating) {
		values = { ...$newOrderInfo };
	}

	if (values.features !== $newOrderInfo.features) {
		selectedEdit = true;
	}

	// Helpers
	const { close } = getContext('simple-modal');

	const deselectProduct = () => {
		$$invalidate(0, selectedProduct = null);
		$$invalidate(1, values = { ...values });
	};

	const decreaseCount = () => {
		$$invalidate(1, values.count--, values);
	};

	const increaseCount = () => {
		if (values.count > 99998) return;
		$$invalidate(1, values.count++, values);
	};

	const handleCountChange = () => {
		if (values.count === null || values.count < 0) $$invalidate(1, values.count = 0, values); else if (values.count > 99999) $$invalidate(1, values.count = 99999, values);
	};

	const handleSubmit = () => {
		if (selectedProduct === null) {
			alert('Selecione um produto!');
			return;
		}

		if (values.ambient === '') {
			alert('Descreva o ambiente para instalação!');
			return;
		}

		if (values.count === 0) {
			alert('Informe a quantidade!');
			return;
		}

		// if (is_empty(selectedFeatures)) {
		//   alert('Informe algum atributo!');
		//   return;
		// }
		// for (let feature of Object.values(values.features)) {
		//   if (feature.value === '') {
		//     alert(`Informe o valor do atributo "${feature.name}"!`);
		//     return;
		//   }
		// }
		$$invalidate(1, values.id = selectedProduct.id, values);

		if (!is_empty(selectedFeatures)) {
			db.collection('products').doc(values.id).update({ features: selectedFeatures }).catch(err => {
				alert(`Erro ao atualizar produto: ${err}`);
			});
		}

		set_store_value(newOrderInfo, $newOrderInfo = { ...values }, $newOrderInfo);

		if (!isCreating) {
			set_store_value(orderEditReady, $orderEditReady = true, $orderEditReady);
		} else {
			set_store_value(newOrderReady, $newOrderReady = true, $newOrderReady);
		}

		close();
	};

	function productselect_selected_binding(value) {
		selectedProduct = value;
		$$invalidate(0, selectedProduct);
	}

	function inputmask_value_binding(value) {
		if ($$self.$$.not_equal(values.ambient, value)) {
			values.ambient = value;
			((($$invalidate(1, values), $$invalidate(0, selectedProduct)), $$invalidate(17, selectedEdit)), $$invalidate(2, selectedFeatures));
		}
	}

	function input_input_handler() {
		values.count = to_number(this.value);
		((($$invalidate(1, values), $$invalidate(0, selectedProduct)), $$invalidate(17, selectedEdit)), $$invalidate(2, selectedFeatures));
	}

	function multiselect_items_binding(value) {
		featureItems = value;
		$$invalidate(3, featureItems);
	}

	function multiselect_selected_binding(value) {
		selectedFeatures = value;
		((($$invalidate(2, selectedFeatures), $$invalidate(0, selectedProduct)), $$invalidate(1, values)), $$invalidate(17, selectedEdit));
	}

	function inputmask_value_binding_1(value, key) {
		if ($$self.$$.not_equal(values.features[key].value, value)) {
			values.features[key].value = value;
			((($$invalidate(1, values), $$invalidate(0, selectedProduct)), $$invalidate(17, selectedEdit)), $$invalidate(2, selectedFeatures));
		}
	}

	const click_handler = (key, item) => {
		$$invalidate(1, values.features[key].value = item.value, values);
	};

	$$self.$$set = $$props => {
		if ('isNew' in $$props) $$invalidate(16, isNew = $$props.isNew);
		if ('selectedProduct' in $$props) $$invalidate(0, selectedProduct = $$props.selectedProduct);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*selectedProduct, values, selectedEdit*/ 131075) {
			$: if (selectedProduct !== null && Object.keys(values.features).length !== 0) {
				// Fetch feature for the selected product
				db.collection('products').doc(selectedProduct.id).get().then(async doc => {
					const product = doc.data();
					const features = product.features;

					if (Object.values(features).length !== 0 && selectedEdit === false) {
						$$invalidate(2, selectedFeatures = [...Object.values(product.features)]);
						$$invalidate(17, selectedEdit = true);
					}

					$$invalidate(1, values = { ...values });
				});
			}
		}

		if ($$self.$$.dirty[0] & /*selectedProduct, values, selectedFeatures, selectedEdit*/ 131079) {
			$: if (selectedProduct !== null && Object.keys(values.features).length === 0) {
				// Fetch feature for the selected product
				db.collection('products').doc(selectedProduct.id).get().then(async doc => {
					const product = doc.data();
					const features = product.features;

					for (let feature of features) {
						// Fetch the feature name from firebase
						const featureDoc = await db.collection('fields').doc(feature).get();

						$$invalidate(1, values.features[feature] = { name: featureDoc.data().name, value: '' }, values);
					}

					if (selectedFeatures.length === 0 && selectedEdit === true) {
						$$invalidate(2, selectedFeatures = [...Object.values(product.features)]);
					}

					// if(Object.values(features).length !== 0) {
					//   selectedFeatures = [ ...Object.values(product.features) ];
					// }
					$$invalidate(1, values = { ...values });
				});
			}
		}
	};

	return [
		selectedProduct,
		values,
		selectedFeatures,
		featureItems,
		newOrderInfo,
		newOrderReady,
		orderEditReady,
		orderEditIndex,
		ambientOptions,
		featureValueOptions,
		isCreating,
		deselectProduct,
		decreaseCount,
		increaseCount,
		handleCountChange,
		handleSubmit,
		isNew,
		selectedEdit,
		productselect_selected_binding,
		inputmask_value_binding,
		input_input_handler,
		multiselect_items_binding,
		multiselect_selected_binding,
		inputmask_value_binding_1,
		click_handler
	];
}

class ProductOrderEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { isNew: 16, selectedProduct: 0 }, null, [-1, -1]);
	}
}

export default ProductOrderEditor;