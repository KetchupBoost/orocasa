import { create_ssr_component, escape, null_to_empty, add_attribute, validate_component, missing_component } from 'svelte/internal';
import { createEventDispatcher, onDestroy, onMount, setContext } from 'svelte';
import { fade } from 'svelte/transition';

/* node_modules\svelte-simple-modal\src\Modal.svelte generated by Svelte v3.46.3 */

const css = {
	code: ".svelte-1l7fz0q{box-sizing:border-box}.bg.svelte-1l7fz0q{position:fixed;z-index:1000;top:0;left:0;display:flex;flex-direction:column;justify-content:center;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.66)}.wrap.svelte-1l7fz0q{position:relative;margin:2rem;max-height:100%}.window.svelte-1l7fz0q{position:relative;width:40rem;max-width:100%;max-height:100%;margin:2rem auto;color:black;border-radius:0.5rem;background:white}.content.svelte-1l7fz0q{position:relative;padding:1rem;max-height:calc(100vh - 4rem);overflow:auto}.close.svelte-1l7fz0q{display:block;box-sizing:border-box;position:absolute;z-index:1000;top:1rem;right:1rem;margin:0;padding:0;width:1.5rem;height:1.5rem;border:0;color:black;border-radius:1.5rem;background:white;box-shadow:0 0 0 1px black;transition:transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);-webkit-appearance:none}.close.svelte-1l7fz0q:before,.close.svelte-1l7fz0q:after{content:'';display:block;box-sizing:border-box;position:absolute;top:50%;width:1rem;height:1px;background:black;transform-origin:center;transition:height 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1)}.close.svelte-1l7fz0q:before{-webkit-transform:translate(0, -50%) rotate(45deg);-moz-transform:translate(0, -50%) rotate(45deg);transform:translate(0, -50%) rotate(45deg);left:0.25rem}.close.svelte-1l7fz0q:after{-webkit-transform:translate(0, -50%) rotate(-45deg);-moz-transform:translate(0, -50%) rotate(-45deg);transform:translate(0, -50%) rotate(-45deg);left:0.25rem}.close.svelte-1l7fz0q:hover{background:black}.close.svelte-1l7fz0q:hover:before,.close.svelte-1l7fz0q:hover:after{height:2px;background:white}.close.svelte-1l7fz0q:focus{border-color:#3399ff;box-shadow:0 0 0 2px #3399ff}.close.svelte-1l7fz0q:active{transform:scale(0.9)}.close.svelte-1l7fz0q:hover,.close.svelte-1l7fz0q:focus,.close.svelte-1l7fz0q:active{outline:none}",
	map: "{\"version\":3,\"file\":\"Modal.svelte\",\"sources\":[\"Modal.svelte\"],\"sourcesContent\":[\"<script context=\\\"module\\\">\\n  /**\\n   * Create a Svelte component with props bound to it.\\n   * @type {(component: Component, props: Record<string, any>) => Component}\\n   */\\n  export function bind(Component, props = {}) {\\n    return function ModalComponent(options) {\\n      return new Component({\\n        ...options,\\n        props: {\\n          ...props,\\n          ...options.props,\\n        },\\n      });\\n    };\\n  }\\n</script>\\n\\n<script>\\n  import * as svelte from 'svelte';\\n  import { fade } from 'svelte/transition';\\n  import { createEventDispatcher } from 'svelte';\\n\\n  const dispatch = createEventDispatcher();\\n\\n  const baseSetContext = svelte.setContext;\\n\\n  /**\\n   * Svelte component to be shown as the modal\\n   * @type {Component | null}\\n   */\\n  export let show = null;\\n\\n  /**\\n   * Svelte context key to reference the simple modal context\\n   * @type {string}\\n   */\\n  export let key = 'simple-modal';\\n\\n  /**\\n   * Accessibility label of the modal\\n   * @see https://www.w3.org/TR/wai-aria-1.1/#aria-label\\n   * @type {string | null}\\n   */\\n  export let ariaLabel = null;\\n\\n  /**\\n   * Element ID holding the accessibility label of the modal\\n   * @see https://www.w3.org/TR/wai-aria-1.1/#aria-labelledby\\n   * @type {string | null}\\n   */\\n  export let ariaLabelledBy = null;\\n\\n  /**\\n   * Whether to show a close button or not\\n   * @type {Component | boolean}\\n   */\\n  export let closeButton = true;\\n\\n  /**\\n   * Whether to close the modal on hitting the escape key or not\\n   * @type {boolean}\\n   */\\n  export let closeOnEsc = true;\\n\\n  /**\\n   * Whether to close the modal upon an outside mouse click or not\\n   * @type {boolean}\\n   */\\n  export let closeOnOuterClick = true;\\n\\n  /**\\n   * CSS for styling the background element\\n   * @type {Record<string, string | number>}\\n   */\\n  export let styleBg = {};\\n\\n  /**\\n   * CSS for styling the window wrapper element\\n   * @type {Record<string, string | number>}\\n   */\\n  export let styleWindowWrap = {};\\n\\n  /**\\n   * CSS for styling the window element\\n   * @type {Record<string, string | number>}\\n   */\\n  export let styleWindow = {};\\n\\n  /**\\n   * CSS for styling the content element\\n   * @type {Record<string, string | number>}\\n   */\\n  export let styleContent = {};\\n\\n  /**\\n   * CSS for styling the close element\\n   * @type {Record<string, string | number>}\\n   */\\n  export let styleCloseButton = {};\\n\\n  /**\\n   * Class name for the background element\\n   * @type {string | null}\\n   */\\n  export let classBg = null;\\n\\n  /**\\n   * Class name for window wrapper element\\n   * @type {string | null}\\n   */\\n  export let classWindowWrap = null;\\n\\n  /**\\n   * Class name for window element\\n   * @type {string | null}\\n   */\\n  export let classWindow = null;\\n\\n  /**\\n   * Class name for content element\\n   * @type {string | null}\\n   */\\n  export let classContent = null;\\n\\n  /**\\n   * Class name for close element\\n   * @type {string | null}\\n   */\\n  export let classCloseButton = null;\\n\\n  /**\\n   * Do not apply default styles to the modal\\n   * @type {boolean}\\n   */\\n  export let unstyled = false;\\n\\n  /**\\n   * @type {(key: any, context: any) => void}\\n   */\\n  export let setContext = baseSetContext;\\n\\n  /**\\n   * Transition function for the background element\\n   * @see https://svelte.dev/docs#transition_fn\\n   * @type {(node: Element, parameters: BlurParams) => TransitionConfig}\\n   */\\n  export let transitionBg = fade;\\n\\n  /**\\n   * Parameters for the background element transition\\n   * @type {BlurParams}\\n   */\\n  export let transitionBgProps = { duration: 250 };\\n\\n  /**\\n   * Transition function for the window element\\n   * @see https://svelte.dev/docs#transition_fn\\n   * @type {(node: Element, parameters: BlurParams) => TransitionConfig}\\n   */\\n  export let transitionWindow = transitionBg;\\n\\n  /**\\n   * Parameters for the window element transition\\n   * @type {BlurParams}\\n   */\\n  export let transitionWindowProps = transitionBgProps;\\n\\n  /**\\n   * If `true` elements outside the modal can be focused\\n   * @type {boolean}\\n   */\\n  export let disableFocusTrap = false;\\n\\n  const defaultState = {\\n    ariaLabel,\\n    ariaLabelledBy,\\n    closeButton,\\n    closeOnEsc,\\n    closeOnOuterClick,\\n    styleBg,\\n    styleWindowWrap,\\n    styleWindow,\\n    styleContent,\\n    styleCloseButton,\\n    classBg,\\n    classWindowWrap,\\n    classWindow,\\n    classContent,\\n    classCloseButton,\\n    transitionBg,\\n    transitionBgProps,\\n    transitionWindow,\\n    transitionWindowProps,\\n    disableFocusTrap,\\n    unstyled,\\n  };\\n  let state = { ...defaultState };\\n\\n  let Component = null;\\n\\n  let background;\\n  let wrap;\\n  let modalWindow;\\n  let scrollY;\\n  let cssBg;\\n  let cssWindowWrap;\\n  let cssWindow;\\n  let cssContent;\\n  let cssCloseButton;\\n  let currentTransitionBg;\\n  let currentTransitionWindow;\\n  let prevBodyPosition;\\n  let prevBodyOverflow;\\n  let prevBodyWidth;\\n  let outerClickTarget;\\n\\n  const camelCaseToDash = (str) =>\\n    str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();\\n\\n  const toCssString = (props) =>\\n    props\\n      ? Object.keys(props).reduce(\\n          (str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`,\\n          ''\\n        )\\n      : '';\\n\\n  const isFunction = (f) => !!(f && f.constructor && f.call && f.apply);\\n\\n  const updateStyleTransition = () => {\\n    cssBg = toCssString(\\n      Object.assign(\\n        {},\\n        {\\n          width: window.innerWidth,\\n          height: window.innerHeight,\\n        },\\n        state.styleBg\\n      )\\n    );\\n    cssWindowWrap = toCssString(state.styleWindowWrap);\\n    cssWindow = toCssString(state.styleWindow);\\n    cssContent = toCssString(state.styleContent);\\n    cssCloseButton = toCssString(state.styleCloseButton);\\n    currentTransitionBg = state.transitionBg;\\n    currentTransitionWindow = state.transitionWindow;\\n  };\\n\\n  const toVoid = () => {};\\n  let onOpen = toVoid;\\n  let onClose = toVoid;\\n  let onOpened = toVoid;\\n  let onClosed = toVoid;\\n\\n  const open = (NewComponent, newProps = {}, options = {}, callback = {}) => {\\n    Component = bind(NewComponent, newProps);\\n    state = { ...defaultState, ...options };\\n    updateStyleTransition();\\n    disableScroll();\\n    onOpen = (event) => {\\n      if (callback.onOpen) callback.onOpen(event);\\n      /**\\n       * The open event is fired right before the modal opens\\n       * @event {void} open\\n       */\\n      dispatch('open');\\n      /**\\n       * The opening event is fired right before the modal opens\\n       * @event {void} opening\\n       * @deprecated Listen to the `open` event instead\\n       */\\n      dispatch('opening'); // Deprecated. Do not use!\\n    };\\n    onClose = (event) => {\\n      if (callback.onClose) callback.onClose(event);\\n      /**\\n       * The close event is fired right before the modal closes\\n       * @event {void} close\\n       */\\n      dispatch('close');\\n      /**\\n       * The closing event is fired right before the modal closes\\n       * @event {void} closing\\n       * @deprecated Listen to the `close` event instead\\n       */\\n      dispatch('closing'); // Deprecated. Do not use!\\n    };\\n    onOpened = (event) => {\\n      if (callback.onOpened) callback.onOpened(event);\\n      /**\\n       * The opened event is fired after the modal's opening transition\\n       * @event {void} opened\\n       */\\n      dispatch('opened');\\n    };\\n    onClosed = (event) => {\\n      if (callback.onClosed) callback.onClosed(event);\\n      /**\\n       * The closed event is fired after the modal's closing transition\\n       * @event {void} closed\\n       */\\n      dispatch('closed');\\n    };\\n  };\\n\\n  const close = (callback = {}) => {\\n    if (!Component) return;\\n    onClose = callback.onClose || onClose;\\n    onClosed = callback.onClosed || onClosed;\\n    Component = null;\\n    enableScroll();\\n  };\\n\\n  const handleKeydown = (event) => {\\n    if (state.closeOnEsc && Component && event.key === 'Escape') {\\n      event.preventDefault();\\n      close();\\n    }\\n\\n    if (Component && event.key === 'Tab' && !state.disableFocusTrap) {\\n      // trap focus\\n      const nodes = modalWindow.querySelectorAll('*');\\n      const tabbable = Array.from(nodes).filter((node) => node.tabIndex >= 0);\\n\\n      let index = tabbable.indexOf(document.activeElement);\\n      if (index === -1 && event.shiftKey) index = 0;\\n\\n      index += tabbable.length + (event.shiftKey ? -1 : 1);\\n      index %= tabbable.length;\\n\\n      tabbable[index].focus();\\n      event.preventDefault();\\n    }\\n  };\\n\\n  const handleOuterMousedown = (event) => {\\n    if (\\n      state.closeOnOuterClick &&\\n      (event.target === background || event.target === wrap)\\n    )\\n      outerClickTarget = event.target;\\n  };\\n\\n  const handleOuterMouseup = (event) => {\\n    if (state.closeOnOuterClick && event.target === outerClickTarget) {\\n      event.preventDefault();\\n      close();\\n    }\\n  };\\n\\n  const disableScroll = () => {\\n    scrollY = window.scrollY;\\n    prevBodyPosition = document.body.style.position;\\n    prevBodyOverflow = document.body.style.overflow;\\n    prevBodyWidth = document.body.style.width;\\n    document.body.style.position = 'fixed';\\n    document.body.style.top = `-${scrollY}px`;\\n    document.body.style.overflow = 'hidden';\\n    document.body.style.width = '100%';\\n  };\\n\\n  const enableScroll = () => {\\n    document.body.style.position = prevBodyPosition || '';\\n    document.body.style.top = '';\\n    document.body.style.overflow = prevBodyOverflow || '';\\n    document.body.style.width = prevBodyWidth || '';\\n    window.scrollTo(0, scrollY);\\n  };\\n\\n  setContext(key, { open, close });\\n\\n  let isMounted = false;\\n\\n  $: {\\n    if (isMounted) {\\n      if (isFunction(show)) {\\n        open(show);\\n      } else {\\n        close();\\n      }\\n    }\\n  }\\n\\n  svelte.onDestroy(() => {\\n    if (isMounted) close();\\n  });\\n\\n  svelte.onMount(() => {\\n    isMounted = true;\\n  });\\n</script>\\n\\n<svelte:window on:keydown={handleKeydown} />\\n\\n{#if Component}\\n  <div\\n    class={state.classBg}\\n    class:bg={!unstyled}\\n    on:mousedown={handleOuterMousedown}\\n    on:mouseup={handleOuterMouseup}\\n    bind:this={background}\\n    transition:currentTransitionBg={state.transitionBgProps}\\n    style={cssBg}\\n  >\\n    <div\\n      class={state.classWindowWrap}\\n      class:wrap={!unstyled}\\n      bind:this={wrap}\\n      style={cssWindowWrap}\\n    >\\n      <div\\n        class={state.classWindow}\\n        class:window={!unstyled}\\n        role=\\\"dialog\\\"\\n        aria-modal=\\\"true\\\"\\n        aria-label={state.ariaLabelledBy ? null : state.ariaLabel || null}\\n        aria-labelledby={state.ariaLabelledBy || null}\\n        bind:this={modalWindow}\\n        transition:currentTransitionWindow={state.transitionWindowProps}\\n        on:introstart={onOpen}\\n        on:outrostart={onClose}\\n        on:introend={onOpened}\\n        on:outroend={onClosed}\\n        style={cssWindow}\\n      >\\n        {#if state.closeButton}\\n          {#if isFunction(state.closeButton)}\\n            <svelte:component this={state.closeButton} onClose={close} />\\n          {:else}\\n            <button\\n              class={state.classCloseButton}\\n              class:close={!unstyled}\\n              aria-label=\\\"Close modal\\\"\\n              on:click={close}\\n              style={cssCloseButton}\\n            />\\n          {/if}\\n        {/if}\\n        <div\\n          class={state.classContent}\\n          class:content={!unstyled}\\n          style={cssContent}\\n        >\\n          <svelte:component this={Component} />\\n        </div>\\n      </div>\\n    </div>\\n  </div>\\n{/if}\\n<slot />\\n\\n<style>\\n  * {\\n    box-sizing: border-box;\\n  }\\n\\n  .bg {\\n    position: fixed;\\n    z-index: 1000;\\n    top: 0;\\n    left: 0;\\n    display: flex;\\n    flex-direction: column;\\n    justify-content: center;\\n    width: 100vw;\\n    height: 100vh;\\n    background: rgba(0, 0, 0, 0.66);\\n  }\\n\\n  .wrap {\\n    position: relative;\\n    margin: 2rem;\\n    max-height: 100%;\\n  }\\n\\n  .window {\\n    position: relative;\\n    width: 40rem;\\n    max-width: 100%;\\n    max-height: 100%;\\n    margin: 2rem auto;\\n    color: black;\\n    border-radius: 0.5rem;\\n    background: white;\\n  }\\n\\n  .content {\\n    position: relative;\\n    padding: 1rem;\\n    max-height: calc(100vh - 4rem);\\n    overflow: auto;\\n  }\\n\\n  .close {\\n    display: block;\\n    box-sizing: border-box;\\n    position: absolute;\\n    z-index: 1000;\\n    top: 1rem;\\n    right: 1rem;\\n    margin: 0;\\n    padding: 0;\\n    width: 1.5rem;\\n    height: 1.5rem;\\n    border: 0;\\n    color: black;\\n    border-radius: 1.5rem;\\n    background: white;\\n    box-shadow: 0 0 0 1px black;\\n    transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);\\n    -webkit-appearance: none;\\n  }\\n\\n  .close:before,\\n  .close:after {\\n    content: '';\\n    display: block;\\n    box-sizing: border-box;\\n    position: absolute;\\n    top: 50%;\\n    width: 1rem;\\n    height: 1px;\\n    background: black;\\n    transform-origin: center;\\n    transition: height 0.2s cubic-bezier(0.25, 0.1, 0.25, 1),\\n      background 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);\\n  }\\n\\n  .close:before {\\n    -webkit-transform: translate(0, -50%) rotate(45deg);\\n    -moz-transform: translate(0, -50%) rotate(45deg);\\n    transform: translate(0, -50%) rotate(45deg);\\n    left: 0.25rem;\\n  }\\n\\n  .close:after {\\n    -webkit-transform: translate(0, -50%) rotate(-45deg);\\n    -moz-transform: translate(0, -50%) rotate(-45deg);\\n    transform: translate(0, -50%) rotate(-45deg);\\n    left: 0.25rem;\\n  }\\n\\n  .close:hover {\\n    background: black;\\n  }\\n\\n  .close:hover:before,\\n  .close:hover:after {\\n    height: 2px;\\n    background: white;\\n  }\\n\\n  .close:focus {\\n    border-color: #3399ff;\\n    box-shadow: 0 0 0 2px #3399ff;\\n  }\\n\\n  .close:active {\\n    transform: scale(0.9);\\n  }\\n\\n  .close:hover,\\n  .close:focus,\\n  .close:active {\\n    outline: none;\\n  }\\n\\n</style>\\n\"],\"names\":[],\"mappings\":\"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\"}"
};

function bind(Component, props = {}) {
	return function ModalComponent(options) {
		return new Component({
				...options,
				props: { ...props, ...options.props }
			});
	};
}

const Modal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	const dispatch = createEventDispatcher();
	const baseSetContext = setContext;
	let { show = null } = $$props;
	let { key = 'simple-modal' } = $$props;
	let { ariaLabel = null } = $$props;
	let { ariaLabelledBy = null } = $$props;
	let { closeButton = true } = $$props;
	let { closeOnEsc = true } = $$props;
	let { closeOnOuterClick = true } = $$props;
	let { styleBg = {} } = $$props;
	let { styleWindowWrap = {} } = $$props;
	let { styleWindow = {} } = $$props;
	let { styleContent = {} } = $$props;
	let { styleCloseButton = {} } = $$props;
	let { classBg = null } = $$props;
	let { classWindowWrap = null } = $$props;
	let { classWindow = null } = $$props;
	let { classContent = null } = $$props;
	let { classCloseButton = null } = $$props;
	let { unstyled = false } = $$props;
	let { setContext: setContext$1 = baseSetContext } = $$props;
	let { transitionBg = fade } = $$props;
	let { transitionBgProps = { duration: 250 } } = $$props;
	let { transitionWindow = transitionBg } = $$props;
	let { transitionWindowProps = transitionBgProps } = $$props;
	let { disableFocusTrap = false } = $$props;

	const defaultState = {
		ariaLabel,
		ariaLabelledBy,
		closeButton,
		closeOnEsc,
		closeOnOuterClick,
		styleBg,
		styleWindowWrap,
		styleWindow,
		styleContent,
		styleCloseButton,
		classBg,
		classWindowWrap,
		classWindow,
		classContent,
		classCloseButton,
		transitionBg,
		transitionBgProps,
		transitionWindow,
		transitionWindowProps,
		disableFocusTrap,
		unstyled
	};

	let state = { ...defaultState };
	let Component = null;
	let background;
	let wrap;
	let modalWindow;
	let scrollY;
	let cssBg;
	let cssWindowWrap;
	let cssWindow;
	let cssContent;
	let cssCloseButton;
	let prevBodyPosition;
	let prevBodyOverflow;
	let prevBodyWidth;
	const camelCaseToDash = str => str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();

	const toCssString = props => props
	? Object.keys(props).reduce((str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`, '')
	: '';

	const isFunction = f => !!(f && f.constructor && f.call && f.apply);

	const updateStyleTransition = () => {
		cssBg = toCssString(Object.assign(
			{},
			{
				width: window.innerWidth,
				height: window.innerHeight
			},
			state.styleBg
		));

		cssWindowWrap = toCssString(state.styleWindowWrap);
		cssWindow = toCssString(state.styleWindow);
		cssContent = toCssString(state.styleContent);
		cssCloseButton = toCssString(state.styleCloseButton);
		state.transitionBg;
		state.transitionWindow;
	};

	const toVoid = () => {
		
	};
	let onClose = toVoid;
	let onClosed = toVoid;

	const open = (NewComponent, newProps = {}, options = {}, callback = {}) => {
		Component = bind(NewComponent, newProps);
		state = { ...defaultState, ...options };
		updateStyleTransition();
		disableScroll();

		onClose = event => {
			if (callback.onClose) callback.onClose(event);

			/**
 * The close event is fired right before the modal closes
 * @event {void} close
 */
			dispatch('close');

			/**
 * The closing event is fired right before the modal closes
 * @event {void} closing
 * @deprecated Listen to the `close` event instead
 */
			dispatch('closing'); // Deprecated. Do not use!
		};

		onClosed = event => {
			if (callback.onClosed) callback.onClosed(event);

			/**
 * The closed event is fired after the modal's closing transition
 * @event {void} closed
 */
			dispatch('closed');
		};
	};

	const close = (callback = {}) => {
		if (!Component) return;
		onClose = callback.onClose || onClose;
		onClosed = callback.onClosed || onClosed;
		Component = null;
		enableScroll();
	};

	const disableScroll = () => {
		scrollY = window.scrollY;
		prevBodyPosition = document.body.style.position;
		prevBodyOverflow = document.body.style.overflow;
		prevBodyWidth = document.body.style.width;
		document.body.style.position = 'fixed';
		document.body.style.top = `-${scrollY}px`;
		document.body.style.overflow = 'hidden';
		document.body.style.width = '100%';
	};

	const enableScroll = () => {
		document.body.style.position = prevBodyPosition || '';
		document.body.style.top = '';
		document.body.style.overflow = prevBodyOverflow || '';
		document.body.style.width = prevBodyWidth || '';
		window.scrollTo(0, scrollY);
	};

	setContext$1(key, { open, close });
	let isMounted = false;

	onDestroy(() => {
		if (isMounted) close();
	});

	onMount(() => {
		isMounted = true;
	});

	if ($$props.show === void 0 && $$bindings.show && show !== void 0) $$bindings.show(show);
	if ($$props.key === void 0 && $$bindings.key && key !== void 0) $$bindings.key(key);
	if ($$props.ariaLabel === void 0 && $$bindings.ariaLabel && ariaLabel !== void 0) $$bindings.ariaLabel(ariaLabel);
	if ($$props.ariaLabelledBy === void 0 && $$bindings.ariaLabelledBy && ariaLabelledBy !== void 0) $$bindings.ariaLabelledBy(ariaLabelledBy);
	if ($$props.closeButton === void 0 && $$bindings.closeButton && closeButton !== void 0) $$bindings.closeButton(closeButton);
	if ($$props.closeOnEsc === void 0 && $$bindings.closeOnEsc && closeOnEsc !== void 0) $$bindings.closeOnEsc(closeOnEsc);
	if ($$props.closeOnOuterClick === void 0 && $$bindings.closeOnOuterClick && closeOnOuterClick !== void 0) $$bindings.closeOnOuterClick(closeOnOuterClick);
	if ($$props.styleBg === void 0 && $$bindings.styleBg && styleBg !== void 0) $$bindings.styleBg(styleBg);
	if ($$props.styleWindowWrap === void 0 && $$bindings.styleWindowWrap && styleWindowWrap !== void 0) $$bindings.styleWindowWrap(styleWindowWrap);
	if ($$props.styleWindow === void 0 && $$bindings.styleWindow && styleWindow !== void 0) $$bindings.styleWindow(styleWindow);
	if ($$props.styleContent === void 0 && $$bindings.styleContent && styleContent !== void 0) $$bindings.styleContent(styleContent);
	if ($$props.styleCloseButton === void 0 && $$bindings.styleCloseButton && styleCloseButton !== void 0) $$bindings.styleCloseButton(styleCloseButton);
	if ($$props.classBg === void 0 && $$bindings.classBg && classBg !== void 0) $$bindings.classBg(classBg);
	if ($$props.classWindowWrap === void 0 && $$bindings.classWindowWrap && classWindowWrap !== void 0) $$bindings.classWindowWrap(classWindowWrap);
	if ($$props.classWindow === void 0 && $$bindings.classWindow && classWindow !== void 0) $$bindings.classWindow(classWindow);
	if ($$props.classContent === void 0 && $$bindings.classContent && classContent !== void 0) $$bindings.classContent(classContent);
	if ($$props.classCloseButton === void 0 && $$bindings.classCloseButton && classCloseButton !== void 0) $$bindings.classCloseButton(classCloseButton);
	if ($$props.unstyled === void 0 && $$bindings.unstyled && unstyled !== void 0) $$bindings.unstyled(unstyled);
	if ($$props.setContext === void 0 && $$bindings.setContext && setContext$1 !== void 0) $$bindings.setContext(setContext$1);
	if ($$props.transitionBg === void 0 && $$bindings.transitionBg && transitionBg !== void 0) $$bindings.transitionBg(transitionBg);
	if ($$props.transitionBgProps === void 0 && $$bindings.transitionBgProps && transitionBgProps !== void 0) $$bindings.transitionBgProps(transitionBgProps);
	if ($$props.transitionWindow === void 0 && $$bindings.transitionWindow && transitionWindow !== void 0) $$bindings.transitionWindow(transitionWindow);
	if ($$props.transitionWindowProps === void 0 && $$bindings.transitionWindowProps && transitionWindowProps !== void 0) $$bindings.transitionWindowProps(transitionWindowProps);
	if ($$props.disableFocusTrap === void 0 && $$bindings.disableFocusTrap && disableFocusTrap !== void 0) $$bindings.disableFocusTrap(disableFocusTrap);
	$$result.css.add(css);

	 {
		{
			if (isMounted) {
				if (isFunction(show)) {
					open(show);
				} else {
					close();
				}
			}
		}
	}

	return `

${Component
	? `<div class="${[
			escape(null_to_empty(state.classBg)) + " svelte-1l7fz0q",
			!unstyled ? "bg" : ""
		].join(' ').trim()}"${add_attribute("style", cssBg, 0)}${add_attribute("this", background, 0)}><div class="${[
			escape(null_to_empty(state.classWindowWrap)) + " svelte-1l7fz0q",
			!unstyled ? "wrap" : ""
		].join(' ').trim()}"${add_attribute("style", cssWindowWrap, 0)}${add_attribute("this", wrap, 0)}><div class="${[
			escape(null_to_empty(state.classWindow)) + " svelte-1l7fz0q",
			!unstyled ? "window" : ""
		].join(' ').trim()}" role="${"dialog"}" aria-modal="${"true"}"${add_attribute("aria-label", state.ariaLabelledBy ? null : state.ariaLabel || null, 0)}${add_attribute("aria-labelledby", state.ariaLabelledBy || null, 0)}${add_attribute("style", cssWindow, 0)}${add_attribute("this", modalWindow, 0)}>${state.closeButton
		? `${isFunction(state.closeButton)
			? `${validate_component(state.closeButton || missing_component, "svelte:component").$$render($$result, { onClose: close }, {}, {})}`
			: `<button class="${[
					escape(null_to_empty(state.classCloseButton)) + " svelte-1l7fz0q",
					!unstyled ? "close" : ""
				].join(' ').trim()}" aria-label="${"Close modal"}"${add_attribute("style", cssCloseButton, 0)}></button>`}`
		: ``}
        <div class="${[
			escape(null_to_empty(state.classContent)) + " svelte-1l7fz0q",
			!unstyled ? "content" : ""
		].join(' ').trim()}"${add_attribute("style", cssContent, 0)}>${validate_component(Component || missing_component, "svelte:component").$$render($$result, {}, {}, {})}</div></div></div></div>`
	: ``}
${slots.default ? slots.default({}) : ``}`;
});

export default Modal;
export { Modal, bind };
