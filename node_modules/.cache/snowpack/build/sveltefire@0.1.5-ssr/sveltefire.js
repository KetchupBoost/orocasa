import { create_ssr_component, validate_store, subscribe, noop } from 'svelte/internal';
import { createEventDispatcher, setContext, onMount, getContext, onDestroy } from 'svelte';
import { writable } from 'svelte/store';

/* node_modules\sveltefire\src\FirebaseApp.svelte generated by Svelte v3.46.3 */

const FirebaseApp = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { firebase } = $$props;
	let { perf = false } = $$props;
	let { analytics = false } = $$props;

	// Ready required to use the app event,
	// prevents child components from running before init
	let ready = false;

	// Emit firebase
	const dispatch = createEventDispatcher();

	// Must be a function to ensure changes after initialization are caught
	setContext("firebase", { getFirebase: () => firebase });

	onMount(() => {
		// Set firebase context from window if needed
		firebase = firebase || window && window.firebase;

		if (!firebase) {
			throw Error("No firebase app was provided. You must provide an initialized Firebase app or make it available globally.");
		} else {
			// Init perf and analytics
			perf && firebase.performance();

			analytics && firebase.analytics();

			// Optional event to set additional config
			dispatch("initializeApp", { firebase });

			ready = true;
		}
	});

	if ($$props.firebase === void 0 && $$bindings.firebase && firebase !== void 0) $$bindings.firebase(firebase);
	if ($$props.perf === void 0 && $$bindings.perf && perf !== void 0) $$bindings.perf(perf);
	if ($$props.analytics === void 0 && $$bindings.analytics && analytics !== void 0) $$bindings.analytics(analytics);
	return `${ready ? `${slots.default ? slots.default({}) : ``}` : ``}`;
});

function getFirebaseContext() {
  const { getFirebase } = getContext('firebase');
  return getFirebase();
}

// Validates end-user has setup context and imported proper modules into the Svelte app
function assertApp(pkg) {

    const app = getFirebaseContext();

    if (!app) {
      throw new Error(`Missing Firebase app in context. Are you inside a 'FirebaseApp' component?`)
    }

    if (pkg) {
        const pkgFn = app[pkg]; 
        if (!pkgFn || !pkgFn()) {
          throw new Error(`Firebase ${pkg} not found. You may be missing "import 'firebase/${pkg}'" `)
        } else {
          return pkgFn();
        }
    } else {
      return app;
    }
}

function userStore(opts = { persist: null }) {

    const auth = assertApp('auth');
    const storageKey = 'sveltefire_user';
    let cached = null;
  
    const { persist } = opts;
  
    if (persist) {
      cached = JSON.parse(opts.persist.getItem(storageKey));
    }
  
    const store = writable(cached, () => {
      const teardown = auth.onAuthStateChanged(u => {
        set(u);
        persist && opts.persist.setItem(storageKey, JSON.stringify(u));
      });
      return () => teardown;
    });
  
    const { subscribe, set } = store;
  
    return {
      subscribe,
      auth
    };
  }

/* node_modules\sveltefire\src\User.svelte generated by Svelte v3.46.3 */

const User = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let $store, $$unsubscribe_store;
	let { persist = null } = $$props;
	let store = userStore({ persist });
	validate_store(store, 'store');
	$$unsubscribe_store = subscribe(store, value => $store = value);
	const dispatch = createEventDispatcher();
	let unsub;

	onMount(() => {
		unsub = store.subscribe(user => {
			dispatch("user", { user });
		});
	});

	onDestroy(() => unsub());
	if ($$props.persist === void 0 && $$bindings.persist && persist !== void 0) $$bindings.persist(persist);
	$$unsubscribe_store();

	return `${slots.before
	? slots.before({ user: $store, auth: store.auth })
	: ``}
${$store
	? `${slots.default
		? slots.default({ user: $store, auth: store.auth })
		: ``}`
	: `${slots["signed-out"]
		? slots["signed-out"]({ user: $store, auth: store.auth })
		: ``}`}
${slots.after
	? slots.after({ user: $store, auth: store.auth })
	: ``}`;
});

function startTrace(name) {
    const perf = assertApp('performance');
    const trace = perf.trace(name);
    trace.start();
    return trace;
  }
  
  async function stopTrace(trace) {
    if (trace.state === 2) {
      trace.stop();
    }
  
    return null;
  }

// Svelte Store for Firestore Document
function docStore(path, opts) {
  const firestore = assertApp('firestore');

  const { startWith, log, traceId, maxWait, once } = { maxWait: 10000, ...opts };

  // Create the Firestore Reference
  const ref = typeof path === 'string' ? firestore.doc(path) : path;

  // Performance trace
  const trace = traceId && startTrace(traceId);

  // Internal state
  let _loading = typeof startWith !== undefined;
  let _firstValue = true;
  let _error = null;
  let _teardown;
  let _waitForIt;


  // State should never change without emitting a new value
  // Clears loading state on first call
  const next = (val, err) => {
    _loading = false; 
    _firstValue = false;
    _waitForIt && clearTimeout(_waitForIt);
    _error = err || null;
    set(val);
    trace && stopTrace(trace);
  };

  // Timout
  // Runs of first subscription
  const start = () => {

    // Timout for fallback slot
    _waitForIt = maxWait && setTimeout(() => _loading && next(null, new Error(`Timeout at ${maxWait}. Using fallback slot.`) ), maxWait);

    // Realtime firebase subscription
    _teardown = ref.onSnapshot(
      snapshot => {
        const data = snapshot.data() || (_firstValue && startWith) || null;

        // Optional logging
        if (log) {
          console.groupCollapsed(`Doc ${snapshot.id}`);
          console.log(`Path: ${ref.path}`);
          console.log('Snapshot:', snapshot);
          console.groupEnd();
        }

        // Emit next value
        next(data);

        // Teardown after first emitted value if once
        once && _teardown();
      },

      // Handle firebase thrown errors
      error => {
        console.error(error);
        next(null, error);
      }
    );

    // Removes firebase listener when store completes
    return () => _teardown();
  };

  // Svelte store
  const store = writable(startWith, start);
  const { subscribe, set } = store;

  return {
    subscribe,
    firestore,
    ref,
    get loading() {
      return _loading;
    },
    get error() {
      return _error;
    }
  };
}

// Svelte Store for Firestore Collection
function collectionStore(path, queryFn, opts) {
  const firestore = assertApp('firestore');

  const { startWith, log, traceId, maxWait, once, idField, refField } = {
    idField: 'id',
    refField: 'ref',
    maxWait: 10000,
    ...opts
  };

  const ref = typeof path === 'string' ? firestore.collection(path) : path;
  const query = queryFn && queryFn(ref);
  const trace = traceId && startTrace(traceId);

  let _loading = typeof startWith !== undefined;
  let _error = null;
  let _meta = {};
  let _teardown;
  let _waitForIt;

  // Metadata for result
  const calcMeta = (val) => {
    return val && val.length ? 
      { first: val[0], last: val[val.length - 1] } : {}
  };

  const next = (val, err) => {
    _loading = false; 
    _waitForIt && clearTimeout(_waitForIt);
    _error = err || null;
    _meta = calcMeta(val);
    set(val);
    trace && stopTrace(trace);
  };

  const start = () => {
    _waitForIt = maxWait && setTimeout(() => _loading && next(null, new Error(`Timeout at ${maxWait}. Using fallback slot.`) ), maxWait);

    _teardown = (query || ref).onSnapshot(
      snapshot => {

        // Will always return an array
        const data = snapshot.docs.map(docSnap => ({
          ...docSnap.data(),
          // Allow end user override fields mapped for ID and Ref
          ...(idField ? { [idField]: docSnap.id } : null),
          ...(refField ? { [refField]: docSnap.ref } : null)
        }));

        if (log) {
          const type = _loading ? 'New Query' : 'Updated Query';
          console.groupCollapsed(`${type} ${ref.id} | ${data.length} hits`);
          console.log(`${ref.path}`);
          console.log(`Snapshot: `, snapshot);
          console.groupEnd();
        }
        next(data);
        once && _teardown();
      },

      error => {
        console.error(error);
        next(null, error);
      }
    );

    return () => _teardown();
  };

  const store = writable(startWith, start);
  const { subscribe, set } = store;

  return {
    subscribe,
    firestore,
    ref,
    get loading() {
      return _loading;
    },
    get error() {
      return _error;
    },
    get meta() {
      return _meta;
    }
  };
}

/* node_modules\sveltefire\src\Doc.svelte generated by Svelte v3.46.3 */

const Doc = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let $store,
		$$unsubscribe_store = noop,
		$$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, $$value => $store = $$value), store);

	let { path } = $$props;
	let { log = false } = $$props;
	let { traceId = "" } = $$props;
	let { startWith = undefined } = $$props;
	let { maxWait = 10000 } = $$props;
	let { once = false } = $$props;
	const opts = { startWith, traceId, log, maxWait, once };
	let store = docStore(path, opts);
	validate_store(store, 'store');
	$$subscribe_store();
	const dispatch = createEventDispatcher();
	let unsub;
	onMount(() => dispatch("ref", { ref: store.ref }));
	onDestroy(() => unsub());
	if ($$props.path === void 0 && $$bindings.path && path !== void 0) $$bindings.path(path);
	if ($$props.log === void 0 && $$bindings.log && log !== void 0) $$bindings.log(log);
	if ($$props.traceId === void 0 && $$bindings.traceId && traceId !== void 0) $$bindings.traceId(traceId);
	if ($$props.startWith === void 0 && $$bindings.startWith && startWith !== void 0) $$bindings.startWith(startWith);
	if ($$props.maxWait === void 0 && $$bindings.maxWait && maxWait !== void 0) $$bindings.maxWait(maxWait);
	if ($$props.once === void 0 && $$bindings.once && once !== void 0) $$bindings.once(once);

	 {
		{
			if (unsub) {
				// Unsub and create new store
				unsub();

				$$subscribe_store(store = docStore(path, opts));
				dispatch("ref", { ref: store.ref });
			}

			unsub = store.subscribe(data => {
				dispatch("data", { data });
			});
		}
	}

	$$unsubscribe_store();

	return `${slots.before
	? slots.before({
			data: $store,
			ref: store.ref,
			error: store.error
		})
	: ``}

${$store
	? `${slots.default
		? slots.default({
				data: $store,
				ref: store.ref,
				error: store.error
			})
		: ``}`
	: `${store.loading
		? `${slots.loading
			? slots.loading({
					data: $store,
					ref: store.ref,
					error: store.error
				})
			: ``}`
		: `${slots.fallback
			? slots.fallback({
					data: $store,
					ref: store.ref,
					error: store.error
				})
			: ``}`}`}

${slots.after
	? slots.after({
			data: $store,
			ref: store.ref,
			error: store.error
		})
	: ``}`;
});

/* node_modules\sveltefire\src\Collection.svelte generated by Svelte v3.46.3 */

const Collection = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let $store,
		$$unsubscribe_store = noop,
		$$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, $$value => $store = $$value), store);

	let { path } = $$props;
	let { query = null } = $$props;
	let { traceId = "" } = $$props;
	let { log = false } = $$props;
	let { startWith = undefined } = $$props;
	let { maxWait = 10000 } = $$props;
	let { once = false } = $$props;
	const opts = { startWith, traceId, log, maxWait, once };
	let store = collectionStore(path, query, opts);
	validate_store(store, 'store');
	$$subscribe_store();
	const dispatch = createEventDispatcher();
	let unsub;
	onMount(() => dispatch("ref", { ref: store.ref }));
	onDestroy(() => unsub());
	if ($$props.path === void 0 && $$bindings.path && path !== void 0) $$bindings.path(path);
	if ($$props.query === void 0 && $$bindings.query && query !== void 0) $$bindings.query(query);
	if ($$props.traceId === void 0 && $$bindings.traceId && traceId !== void 0) $$bindings.traceId(traceId);
	if ($$props.log === void 0 && $$bindings.log && log !== void 0) $$bindings.log(log);
	if ($$props.startWith === void 0 && $$bindings.startWith && startWith !== void 0) $$bindings.startWith(startWith);
	if ($$props.maxWait === void 0 && $$bindings.maxWait && maxWait !== void 0) $$bindings.maxWait(maxWait);
	if ($$props.once === void 0 && $$bindings.once && once !== void 0) $$bindings.once(once);

	 {
		{
			if (unsub) {
				unsub();
				$$subscribe_store(store = collectionStore(path, query, opts));
				dispatch("ref", { ref: store.ref });
			}

			unsub = store.subscribe(data => {
				dispatch("data", { data });
			});
		}
	}

	$$unsubscribe_store();

	return `${slots.before
	? slots.before({
			data: $store,
			ref: store.ref,
			error: store.error,
			first: store.meta.first,
			last: store.meta.last
		})
	: ``}
${$store
	? `${slots.default
		? slots.default({
				data: $store,
				ref: store.ref,
				error: store.error,
				first: store.meta.first,
				last: store.meta.last
			})
		: ``}`
	: `${store.loading
		? `${slots.loading
			? slots.loading({
					data: $store,
					ref: store.ref,
					error: store.error,
					first: store.meta.first,
					last: store.meta.last
				})
			: ``}`
		: `${slots.fallback
			? slots.fallback({
					data: $store,
					ref: store.ref,
					error: store.error,
					first: store.meta.first,
					last: store.meta.last
				})
			: ``}`}`}
${slots.after
	? slots.after({
			data: $store,
			ref: store.ref,
			error: store.error,
			first: store.meta.first,
			last: store.meta.last
		})
	: ``}`;
});

// Svelte Store for Storage file
function fileDownloadStore(path, opts) {
  const storage = assertApp('storage');

  const { log, traceId, startWith, url, meta, } = { url: true, ...opts };

  const storageRef = storage.ref();
  const ref = typeof path === 'string' ? storageRef.child(path) : path;

  // Performance trace
  const trace = traceId && startTrace(traceId);

  // Internal state
  let _loading = typeof startWith !== undefined;
  let _error = null;

  // State should never change without emitting a new value
  // Clears loading state on first call
  const next = (val, err) => {
    _loading = false; 
    _error = err || null;
    set(val);
    trace && stopTrace(trace);
  };

  // Timout
  // Runs of first subscription
    const start = async() => {

      const requests = [url && ref.getDownloadURL(), meta && ref.getMetadata()];

      Promise.all(requests)
              .then(result => next({
                url: result[0],
                metadata: result[1]
              }))
              .catch(e => next(null, e));

    };


  // Svelte store
  const store = writable(startWith, start);
  const { subscribe, set } = store;

  return {
    subscribe,
    storage,
    ref,
    get loading() {
      return _loading;
    },
    get error() {
      return _error;
    }
  };
}

function uploadTaskStore(path, file, opts) {
  const storage = assertApp('storage');

  const { log, traceId } = { ...opts };

  const storageRef = storage.ref();
  
  const ref = typeof path === 'string' ? storageRef.child(path) : path;

  // Performance trace
  const trace = traceId && startTrace(traceId);

  // Internal state
  let _error = null;
  let _url = ''; // download url
  let _task; // upload task

  // Emits UploadTaskSnapshot
  const next = (val, err) => {
    _error = err || null;
    set(val);
  };

  const start = () => {
    _task = ref.put(file);

    const _teardown = _task.on('state_changed', {
      next: (snap) => next(snap),
      error: (e) => next(_task.snapshot, e),
      complete: () => {
        console.log('done');
        ref.getDownloadURL().then(url => {
          next(_task.snapshot);
          _url = url;
          if (log) console.log(`Upload Complete: ${url}`);
          trace && stopTrace(trace);
        });
      }
    });

    return () => _teardown();
  };

  const store = writable(null, start);
  const { subscribe, set } = store;

  return {
    subscribe,
    storage,
    ref,
    get downloadURL() {
      return _url;
    },
    get task() {
      return _task;
    },
    get error() {
      return _error;
    },
  };
}

/* node_modules\sveltefire\src\StorageRef.svelte generated by Svelte v3.46.3 */

const StorageRef = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let $store,
		$$unsubscribe_store = noop,
		$$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, $$value => $store = $$value), store);

	let { path = "" } = $$props;
	let { log = false } = $$props;
	let { traceId = "" } = $$props;
	let { startWith = undefined } = $$props;
	let { url = true } = $$props;
	let { meta = false } = $$props;
	const opts = { startWith, traceId, log, meta, url };
	let store = fileDownloadStore(path, opts);
	validate_store(store, 'store');
	$$subscribe_store();
	const dispatch = createEventDispatcher();
	let unsub;
	onMount(() => dispatch("ref", { ref: store.ref }));
	onDestroy(() => unsub());
	if ($$props.path === void 0 && $$bindings.path && path !== void 0) $$bindings.path(path);
	if ($$props.log === void 0 && $$bindings.log && log !== void 0) $$bindings.log(log);
	if ($$props.traceId === void 0 && $$bindings.traceId && traceId !== void 0) $$bindings.traceId(traceId);
	if ($$props.startWith === void 0 && $$bindings.startWith && startWith !== void 0) $$bindings.startWith(startWith);
	if ($$props.url === void 0 && $$bindings.url && url !== void 0) $$bindings.url(url);
	if ($$props.meta === void 0 && $$bindings.meta && meta !== void 0) $$bindings.meta(meta);

	 {
		{
			if (unsub) {
				// Unsub and create new store
				unsub();

				$$subscribe_store(store = fileDownloadStore(path, opts));
				dispatch("ref", { ref: store.ref });
			}

			unsub = store.subscribe(result => {
				if (result) {
					dispatch("storageResult", {
						downloadURL: result[0],
						metadata: result[1]
					});
				}
			});
		}
	}

	$$unsubscribe_store();

	return `${slots.before
	? slots.before({
			downloadURL: $store && $store.url,
			metadata: $store && $store.metadata,
			ref: store.ref,
			error: store.error
		})
	: ``}

${$store
	? `${slots.default
		? slots.default({
				downloadURL: $store && $store.url,
				metadata: $store && $store.metadata,
				ref: store.ref,
				error: store.error
			})
		: ``}`
	: `${store.loading
		? `${slots.loading
			? slots.loading({
					downloadURL: $store && $store.url,
					metadata: $store && $store.metadata,
					ref: store.ref,
					error: store.error
				})
			: ``}`
		: `${slots.fallback
			? slots.fallback({
					downloadURL: $store && $store.url,
					metadata: $store && $store.metadata,
					ref: store.ref,
					error: store.error
				})
			: ``}`}`}

${slots.after
	? slots.after({
			downloadURL: $store && $store.url,
			metadata: $store && $store.metadata,
			ref: store.ref,
			error: store.error
		})
	: ``}`;
});

/* node_modules\sveltefire\src\UploadTask.svelte generated by Svelte v3.46.3 */

const UploadTask = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let $store,
		$$unsubscribe_store = noop,
		$$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, $$value => $store = $$value), store);

	let { path } = $$props;
	let { file } = $$props;
	let { log = false } = $$props;
	let { traceId = "" } = $$props;
	const opts = { traceId, log };
	let store = uploadTaskStore(path, file, opts);
	validate_store(store, 'store');
	$$subscribe_store();
	const dispatch = createEventDispatcher();
	let unsub;
	onMount(() => dispatch("ref", { ref: store.ref }));
	onDestroy(() => unsub());
	if ($$props.path === void 0 && $$bindings.path && path !== void 0) $$bindings.path(path);
	if ($$props.file === void 0 && $$bindings.file && file !== void 0) $$bindings.file(file);
	if ($$props.log === void 0 && $$bindings.log && log !== void 0) $$bindings.log(log);
	if ($$props.traceId === void 0 && $$bindings.traceId && traceId !== void 0) $$bindings.traceId(traceId);

	 {
		{
			if (unsub) {
				// Unsub and create new store
				unsub();

				$$subscribe_store(store = uploadTaskStore(path, file, opts));
				dispatch("ref", { ref: store.ref });
			}

			unsub = store.subscribe(snapshot => {
				dispatch("snapshot", { snapshot });
			});
		}
	}

	$$unsubscribe_store();

	return `${slots.before
	? slots.before({
			snapshot: $store,
			ref: store.ref,
			task: store.task,
			downloadURL: store.downloadURL,
			error: store.error
		})
	: ``}

${$store
	? `${slots.default
		? slots.default({
				snapshot: $store,
				ref: store.ref,
				task: store.task,
				downloadURL: store.downloadURL,
				error: store.error
			})
		: ``}`
	: `${slots.fallback
		? slots.fallback({
				snapshot: $store,
				ref: store.ref,
				task: store.task,
				downloadURL: store.downloadURL,
				error: store.error
			})
		: ``}`}

${store.downloadURL
	? `${slots.complete
		? slots.complete({
				snapshot: $store,
				ref: store.ref,
				task: store.task,
				downloadURL: store.downloadURL,
				error: store.error
			})
		: ``}`
	: ``}

${slots.after
	? slots.after({
			snapshot: $store,
			ref: store.ref,
			task: store.task,
			downloadURL: store.downloadURL,
			error: store.error
		})
	: ``}`;
});

export { Collection, Doc, FirebaseApp, StorageRef, UploadTask, User, collectionStore, docStore, fileDownloadStore, uploadTaskStore, userStore };
